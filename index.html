<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>terminal-demo</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 40px 20px;
      font-family: system-ui, -apple-system, sans-serif;
    }
    .container {
      width: 100%;
      max-width: 900px;
    }
    .demo-info {
      text-align: center;
      color: #8b949e;
      margin-bottom: 24px;
    }
    .demo-info h1 {
      color: #f0f6fc;
      font-size: 32px;
      margin-bottom: 8px;
    }
    .demo-info p {
      font-size: 15px;
    }
    .controls {
      margin-top: 24px;
      display: flex;
      gap: 12px;
      justify-content: center;
    }
    .controls button {
      padding: 10px 24px;
      border-radius: 6px;
      font-size: 14px;
      cursor: pointer;
      border: none;
      font-weight: 500;
      transition: all 0.2s;
    }
    #play-btn {
      background: #7ee787;
      color: #0d1117;
    }
    #play-btn:hover { filter: brightness(1.1); }
    #pause-btn {
      background: #f0883e;
      color: #0d1117;
    }
    #pause-btn:hover { filter: brightness(1.1); }
    #reset-btn {
      background: #21262d;
      color: #c9d1d9;
    }
    #reset-btn:hover { filter: brightness(1.2); }
    #record-btn {
      background: #f85149;
      color: #ffffff;
    }
    #record-btn:hover { filter: brightness(1.1); }
    #record-btn.recording {
      animation: pulse 1s infinite;
    }
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.6; }
    }
    .scenarios {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      justify-content: center;
      margin-top: 16px;
    }
    .scenario-btn {
      background: #21262d;
      color: #c9d1d9;
      border: 1px solid #8b949e;
      padding: 6px 14px;
      border-radius: 20px;
      font-size: 13px;
      cursor: pointer;
      transition: all 0.2s;
    }
    .scenario-btn:hover {
      background: #8b949e;
    }
    .scenario-btn.active {
      background: #7ee787;
      border-color: #7ee787;
      color: #0d1117;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="demo-info">
      <h1>terminal-demo</h1>
      <p>Animated terminal demo component for showcasing CLI tools</p>
    </div>
    <div id="demo"></div>
    <div class="scenarios" id="scenarios"></div>
    <div class="controls">
      <button id="play-btn">Play All</button>
      <button id="pause-btn">Pause</button>
      <button id="reset-btn">Reset</button>
      <button id="record-btn">ðŸ”´ Record GIF</button>
    </div>
  </div>

  <script type="module">
    import { TerminalDemo } from './src/terminal-demo.ts'
    import GIF from 'gif.js'
    import html2canvas from 'html2canvas'

    const scenarios = [
      {
        name: 'âœ¨ New Features',
        description: 'Demo of select, multiselect, and progress',
        steps: [
          { type: 'prompt' },
          { type: 'command', text: 'demo --features', delay: 60 },
          { type: 'wait', ms: 400 },
          { type: 'output', text: '' },
          { type: 'output', text: '[bold][cyan]â”â”â” Select (Single Choice) â”â”â”[/cyan][/bold]' },
          { type: 'output', text: '' },
          { type: 'select', question: 'Choose your framework:', options: ['React', 'Vue', 'Angular', 'Svelte'], selected: 0, duration: 1800 },
          { type: 'wait', ms: 500 },
          { type: 'output', text: '' },
          { type: 'output', text: '[bold][purple]â”â”â” Multiselect (Multiple Choice) â”â”â”[/purple][/bold]' },
          { type: 'output', text: '' },
          { type: 'multiselect', question: 'Select plugins to install:', options: ['TypeScript', 'ESLint', 'Prettier', 'Tailwind CSS'], selected: [0, 1, 2], duration: 3000 },
          { type: 'wait', ms: 500 },
          { type: 'output', text: '' },
          { type: 'output', text: '[bold][yellow]â”â”â” Progress Bar â”â”â”[/yellow][/bold]' },
          { type: 'output', text: '' },
          { type: 'progress', text: 'Downloading packages...', duration: 1500, percent: 100 },
          { type: 'progress', text: 'Building project...    ', duration: 2000, percent: 100 },
          { type: 'progress', text: 'Running tests...       ', duration: 1000, percent: 100 },
          { type: 'output', text: '' },
          { type: 'output', text: '[green]âœ“ All done![/green]' },
          { type: 'wait', ms: 1500 },
        ]
      },
      {
        name: 'gut commit',
        description: 'AI-generated commit messages',
        steps: [
          { type: 'prompt' },
          { type: 'command', text: 'gut commit', delay: 60 },
          { type: 'wait', ms: 400 },
          { type: 'output', text: '[gray]No staged changes, staging all changes...[/gray]' },
          { type: 'spinner', text: 'Generating commit message...', duration: 1800 },
          { type: 'output', text: '' },
          { type: 'output', text: '[bold]Generated commit message:[/bold]' },
          { type: 'output', text: '' },
          { type: 'output', text: '  [green]feat(auth): add secure API key storage[/green]' },
          { type: 'output', text: '  [gray]- Implement keytar for macOS Keychain[/gray]' },
          { type: 'output', text: '  [gray]- Add environment variable fallback[/gray]' },
          { type: 'output', text: '' },
          { type: 'question', text: 'Commit with this message? (y/N/e to edit) ' },
          { type: 'wait', ms: 600 },
          { type: 'answer', text: 'y' },
          { type: 'output', text: '[green]âœ“ Committed successfully[/green]' },
          { type: 'wait', ms: 1000 },
        ]
      },
      {
        name: 'gut pr',
        description: 'Generate PR descriptions',
        steps: [
          { type: 'prompt' },
          { type: 'command', text: 'gut pr --create', delay: 60 },
          { type: 'wait', ms: 400 },
          { type: 'spinner', text: 'Analyzing branch...', duration: 600 },
          { type: 'spinner', text: 'Generating PR description...', duration: 1500 },
          { type: 'output', text: '' },
          { type: 'output', text: '[bold]ðŸ“ Generated PR:[/bold]' },
          { type: 'output', text: '' },
          { type: 'output', text: '[cyan]Title:[/cyan] [white]feat(auth): Add secure API key storage[/white]' },
          { type: 'output', text: '' },
          { type: 'output', text: '[cyan]Description:[/cyan]' },
          { type: 'output', text: '[gray]â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€[/gray]' },
          { type: 'output', text: '## Summary' },
          { type: 'output', text: 'Implements secure API key storage using system keychain.' },
          { type: 'output', text: '' },
          { type: 'output', text: '## Changes' },
          { type: 'output', text: '- Added keytar integration' },
          { type: 'output', text: '- Support for multiple AI providers' },
          { type: 'output', text: '[gray]â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€[/gray]' },
          { type: 'question', text: 'Create PR? (y/N) ' },
          { type: 'wait', ms: 600 },
          { type: 'answer', text: 'y' },
          { type: 'spinner', text: 'Creating PR...', duration: 1200 },
          { type: 'output', text: '[green]âœ“ PR created successfully![/green]' },
          { type: 'output', text: '' },
          { type: 'output', text: '[green]ðŸ”— https://github.com/user/repo/pull/42[/green]' },
          { type: 'wait', ms: 1000 },
        ]
      },
      {
        name: 'gut review',
        description: 'AI code review',
        steps: [
          { type: 'prompt' },
          { type: 'command', text: 'gut review', delay: 60 },
          { type: 'wait', ms: 400 },
          { type: 'spinner', text: 'Analyzing changes...', duration: 2000 },
          { type: 'output', text: '' },
          { type: 'output', text: '[bold]ðŸ” Code Review Results[/bold]' },
          { type: 'output', text: '' },
          { type: 'output', text: '[cyan]Overall:[/cyan] [green]Good[/green] - Well-structured code' },
          { type: 'output', text: '' },
          { type: 'output', text: '[yellow]âš  src/lib/credentials.ts:45[/yellow]' },
          { type: 'output', text: '  [gray]Consider adding error handling for keychain failures[/gray]' },
          { type: 'output', text: '' },
          { type: 'output', text: '[green]âœ“ src/commands/auth.ts[/green]' },
          { type: 'output', text: '  [gray]Clean implementation of auth flow[/gray]' },
          { type: 'wait', ms: 1500 },
        ]
      },
      {
        name: 'gut init',
        description: 'Interactive project setup',
        steps: [
          { type: 'prompt' },
          { type: 'command', text: 'gut init', delay: 60 },
          { type: 'wait', ms: 400 },
          { type: 'output', text: '' },
          { type: 'output', text: '[bold]ðŸš€ Initialize gut-cli[/bold]' },
          { type: 'output', text: '' },
          { type: 'select', question: 'Select AI provider:', options: ['OpenAI', 'Anthropic', 'Google AI', 'Local LLM'], selected: 1, duration: 1500 },
          { type: 'wait', ms: 300 },
          { type: 'multiselect', question: 'Select features:', options: ['Auto-commit', 'PR generation', 'Code review', 'Branch naming'], selected: [0, 1, 2], duration: 2500 },
          { type: 'wait', ms: 300 },
          { type: 'output', text: '' },
          { type: 'progress', text: 'Installing dependencies...', duration: 2000, percent: 100 },
          { type: 'output', text: '' },
          { type: 'output', text: '[green]âœ“ gut-cli initialized successfully![/green]' },
          { type: 'output', text: '[gray]Run `gut --help` to see available commands[/gray]' },
          { type: 'wait', ms: 1000 },
        ]
      }
    ]

    const demo = new TerminalDemo(document.getElementById('demo'), {
      title: 'gut-cli demo â€” zsh',
      scenarios,
      theme: 'dark',
      windowStyle: 'macos',
    })

    // Create scenario buttons
    const scenariosEl = document.getElementById('scenarios')
    scenarios.forEach((scenario, index) => {
      const btn = document.createElement('button')
      btn.className = 'scenario-btn'
      btn.textContent = scenario.name
      btn.title = scenario.description ?? ''
      btn.addEventListener('click', () => demo.playScenario(index))
      scenariosEl.appendChild(btn)
    })

    document.getElementById('play-btn').addEventListener('click', () => demo.play())
    document.getElementById('reset-btn').addEventListener('click', () => demo.reset())

    // Pause/Resume toggle
    const pauseBtn = document.getElementById('pause-btn')
    pauseBtn.addEventListener('click', () => {
      if (demo.isPaused()) {
        demo.resume()
        pauseBtn.textContent = 'Pause'
      } else {
        demo.pause()
        pauseBtn.textContent = 'Resume'
      }
    })

    // GIF Recording
    let isRecording = false
    const recordBtn = document.getElementById('record-btn')

    async function recordGif() {
      const terminal = demo.getTerminalElement()
      if (!terminal) throw new Error('Terminal element not found')

      const fps = 10
      const scale = 1
      const frameDelay = 1000 / fps

      return new Promise((resolve, reject) => {
        const gifEncoder = new GIF({
          workers: 2,
          quality: 1,
          width: terminal.offsetWidth * scale,
          height: terminal.offsetHeight * scale,
          workerScript: '/gif.worker.js',
          dither: false
        })

        gifEncoder.on('finished', (blob) => {
          isRecording = false
          resolve(blob)
        })

        isRecording = true
        recordBtn.textContent = 'âº Recording...'

        const frameInterval = setInterval(async () => {
          if (!isRecording) return
          try {
            const canvas = await html2canvas(terminal, {
              backgroundColor: null,
              scale,
              logging: false
            })
            gifEncoder.addFrame(canvas, { delay: frameDelay, copy: true })
          } catch (err) {
            console.error('Failed to capture frame:', err)
          }
        }, frameDelay)

        demo.play()
          .then(() => new Promise(r => setTimeout(r, 500)))
          .then(() => {
            clearInterval(frameInterval)
            isRecording = false
            recordBtn.textContent = 'âš™ Processing...'
            gifEncoder.render()
          })
          .catch((err) => {
            clearInterval(frameInterval)
            isRecording = false
            reject(err)
          })
      })
    }

    recordBtn.addEventListener('click', async () => {
      if (isRecording) return

      recordBtn.classList.add('recording')

      try {
        const blob = await recordGif()

        // Download the GIF
        const url = URL.createObjectURL(blob)
        const a = document.createElement('a')
        a.href = url
        a.download = 'terminal-demo.gif'
        a.click()
        URL.revokeObjectURL(url)

        recordBtn.textContent = 'âœ“ Downloaded!'
        setTimeout(() => {
          recordBtn.classList.remove('recording')
          recordBtn.textContent = 'ðŸ”´ Record GIF'
        }, 2000)
      } catch (err) {
        console.error('Recording failed:', err)
        alert('Recording failed: ' + err.message)
        recordBtn.classList.remove('recording')
        recordBtn.textContent = 'ðŸ”´ Record GIF'
      }
    })
  </script>
</body>
</html>
